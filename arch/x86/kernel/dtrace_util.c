/*
 * FILE:	dtrace_util.c
 * DESCRIPTION:	Dynamic Tracing: Architecture utility functions
 *
 * Copyright (C) 2010-2014 Oracle Corporation
 */

#include <linux/dtrace_cpu.h>
#include <linux/kdebug.h>
#include <linux/module.h>
#include <linux/notifier.h>
#include <linux/slab.h>
#include <asm/insn.h>
#include <asm/ptrace.h>

/*
 * Move the instruction pointer forward to the next instruction, effectiely
 * skipping the current one.
 */
void dtrace_skip_instruction(struct pt_regs *regs) {
	struct insn		insn;

	kernel_insn_init(&insn, (void *)regs->ip, MAX_INSN_SIZE);
	insn_get_length(&insn);

	regs->ip += insn.length;
}

void dtrace_handle_badaddr(struct pt_regs *regs) {
	unsigned long	addr = read_cr2();

	DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
	this_cpu_core->cpuc_dtrace_illval = addr;

	dtrace_skip_instruction(regs);
}

typedef struct dtrace_invop_hdlr {
	uint8_t				(*dtih_func)(struct pt_regs *);
	struct dtrace_invop_hdlr	*dtih_next;
} dtrace_invop_hdlr_t;

static dtrace_invop_hdlr_t	*dtrace_invop_hdlrs;

#define INVOP_TRAP_INSTR	0xf0

/*
 * Trap notification handler.
 */
int dtrace_die_notifier(struct notifier_block *nb, unsigned long val,
			void *args)
{
	struct die_args		*dargs = args;

	switch (val) {
	case DIE_PAGE_FAULT: {
		if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
			return NOTIFY_DONE;

		dtrace_handle_badaddr(dargs->regs);

		return NOTIFY_OK | NOTIFY_STOP_MASK;
	}
	case DIE_GPF: {
		struct insn	insn;

		kernel_insn_init(&insn, (void *)dargs->regs->ip, MAX_INSN_SIZE);
		insn_get_length(&insn);

		/*
		 * It would seem that the invalid opcode generated by the LOCK
		 * prefix (0xF0) used for SDT probe points may get delivered as
		 * a general protection failure on Xen.  We need to ignore them
		 * as general protection failures...
		 */
		if (insn.length != 5 || insn.prefixes.bytes[0] != 0xf0 ||
		    insn.opcode.bytes[0] != 0x90) {
			if (!DTRACE_CPUFLAG_ISSET(CPU_DTRACE_NOFAULT))
				return NOTIFY_DONE;

			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);

			dargs->regs->ip += insn.length;

			return NOTIFY_OK | NOTIFY_STOP_MASK;
		}

		/*
		 * ... and instead treat them as the SDT probe point traps that
		 * they are.
		 */
		dargs->trapnr = 6;
	}
	case DIE_TRAP: {
		dtrace_invop_hdlr_t	*hdlr;
		int			rval = 0;

		if (dargs->trapnr != 6)
			return NOTIFY_DONE;

		for (hdlr = dtrace_invop_hdlrs; hdlr != NULL;
		     hdlr = hdlr->dtih_next) {
			if ((rval = hdlr->dtih_func(dargs->regs)) != 0)
				break;
		}

		if (rval != 0) {
			dtrace_skip_instruction(dargs->regs);

			return NOTIFY_OK | NOTIFY_STOP_MASK;
		}
	}
	default:
		return NOTIFY_DONE;
	}
}

/*
 * Add an INVOP trap handler.
 */
int dtrace_invop_add(uint8_t (*func)(struct pt_regs *))
{
	dtrace_invop_hdlr_t	*hdlr;

	hdlr = kmalloc(sizeof(dtrace_invop_hdlr_t), GFP_KERNEL);
	if (hdlr == NULL) {
		pr_warn("Failed to add invop handler: out of memory\n");
		return -ENOMEM;
	}

	hdlr->dtih_func = func;
	hdlr->dtih_next = dtrace_invop_hdlrs;
	dtrace_invop_hdlrs = hdlr;

	return 0;
}
EXPORT_SYMBOL(dtrace_invop_add);

/*
 * Remove an INVOP trap handler.
 */
void dtrace_invop_remove(uint8_t (*func)(struct pt_regs *))
{
	dtrace_invop_hdlr_t	*hdlr = dtrace_invop_hdlrs, *prev = NULL;

	for (;;) {
		if (hdlr == NULL)
			return;

		if (hdlr->dtih_func == func)
			break;

		prev = hdlr;
		hdlr = hdlr->dtih_next;
	}

	if (prev == NULL) {
		dtrace_invop_hdlrs = hdlr->dtih_next;
	} else
		prev->dtih_next = hdlr->dtih_next;

	kfree(hdlr);
}
EXPORT_SYMBOL(dtrace_invop_remove);

/*
 * Enable an INVOP-based probe, i.e. ensure that an INVOP trap is triggered at
 * the specified address.
 */
void dtrace_invop_enable(uint8_t *addr)
{
	text_poke(addr, ((unsigned char []){INVOP_TRAP_INSTR}), 1);
}
EXPORT_SYMBOL(dtrace_invop_enable);

/*
 * Disable an INVOP-based probe.
 */
void dtrace_invop_disable(uint8_t *addr, uint8_t opcode)
{
	text_poke(addr, ((unsigned char []){opcode}), 1);
}
EXPORT_SYMBOL(dtrace_invop_disable);
